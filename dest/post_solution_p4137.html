<!--
题解 P4137 【Rmq Problem / mex】
我们考虑莫队的做法。如果我们删除一个数，那么用被删的数更新mex即可。如果加入一个数，似乎比较麻烦（至少本蒟蒻没想出来）。
-->
<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>题解 P4137 【Rmq Problem / mex】 -- Wycero's blog</title>
<link rel="stylesheet" type="text/css" href="wycero-1.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.js"></script>
<link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  
<script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  
<script >hljs.initHighlightingOnLoad();</script>  
<link href="icon.png" rel="Shortcut Icon">
</head>
<body id="body">
<div class="top-bar">
<a href="index.html" class="tpi icon-top"><img src="home.svg" class="svg"></img></a>
<p class="tpi">题解 P4137 【Rmq Problem / mex】</p>
<a href="#" class="tpi icon-top"><img src="top.svg" class="svg"></img></a></div>
<br><br><br><br>
<p>我们考虑莫队的做法。如果我们删除一个数，那么用被删的数更新mex即可。如果加入一个数，似乎比较麻烦（至少本蒟蒻没想出来）。 </p>
<p>于是我们借鉴回滚莫队的思想，写出只需删除不需插入的莫队。 </p>
<p>大于n的数对答案无影响，在处理时可以直接忽略。</p>
<pre><code class=cpp>// luogu-judger-enable-o2
#include&ltbits/stdc++.h&gt
#define rep(i,a,b) for(int i=a;i&lt=b;i++)
using namespace std;
const int maxn=2e+5+5;
int n,m,ksiz;
int aa[maxn];
int bb[maxn];
int bl[maxn];
//unordered_map&ltint,int&gt se;
//unordered_map&ltint,int&gt se2;
int se[maxn],se2[maxn];
int ans=0,ans2=0,ans3=0;
struct query{
    int l;
    int r;
    int ans;
    int id;
}qq[maxn];
bool operator &lt(query x,query y){
    return bl[x.l]==bl[y.l]?x.r&gty.r:bl[x.l]&ltbl[y.l];
}
int cnt=0;
void add(int pos){
    cnt++;
    if(aa[pos]&gtn+1)return;
    se[aa[pos]]++;
}
void del(int pos,int &ampmyans){
    cnt++;
    if(aa[pos]&gtn+1)return;
    se[aa[pos]]--;
    if(se[aa[pos]]==0)myans=min(myans,aa[pos]);
}
int res[maxn];
int main(){
    scanf(&quot%d%d&quot,&ampn,&ampm);
    rep(i,1,n)scanf(&quot%d&quot,aa+i),bb[i]=aa[i];
    sort(bb+1,bb+n+1);
    rep(i,1,n)if(bb[i]==ans)ans++;
    ksiz=sqrt(n);
    rep(i,1,n)bl[i]=(i-1)/ksiz*ksiz+1;
    rep(i,1,m)scanf(&quot%d%d&quot,&ampqq[i].l,&ampqq[i].r);
    rep(i,1,m)qq[i].id=i;
    sort(qq+1,qq+m+1);
    int l=1,r=n;
    rep(i,1,n)se[aa[i]]++;
    ans2=ans;
    rep(i,1,m){
        if(bl[qq[i].l]==bl[qq[i].r]){
            rep(j,qq[i].l,qq[i].r)if(aa[j]&lt=n+1)se2[aa[j]]++;
            qq[i].ans=0;
            while(se2[qq[i].ans])qq[i].ans++;
            rep(j,qq[i].l,qq[i].r)if(aa[j]&lt=n+1)se2[aa[j]]--;
            continue;
        }
        while(l&ltbl[qq[i].l]){
            while(r&ltn)add(++r); //restore right
            del(l++,ans); //move kuai
            ans2=ans;
        }
        while(r&gtqq[i].r)del(r--,ans2); //move right
        ans3=ans2;
        int lpie=l;
        while(lpie&ltqq[i].l)del(lpie++,ans3);
        while(lpie&gtl)add(--lpie);
        qq[i].ans=ans3;
    }
    rep(i,1,m)res[qq[i].id]=qq[i].ans;
    rep(i,1,m)printf(&quot%d\n&quot,res[i]);
    //cout&lt&ltcnt&lt&ltendl;
    return 0;
}</pre></code><footer>
<script src="wycero-1.js"></script>
<p>Copyright 2019 wycero</p>
<p>Powered By: 
<a href="http://php.net">PHP</a>
<a href="https://katex.org">$\KaTeX$</a>
<a href="https://highlightjs.org/">Highlightjs</a></p>
<p>Hosted On coding.me</p>
</footer>
<script>
    renderMathInElement(document.body,
   {
              delimiters: [
                  {left: "$$", right: "$$", display: true},
                  {left: "$", right: "$", display: false},
                  {left: "\\(", right: "\\)", display: false}
              ]
          }
  );
</script>

</body>
</html>
